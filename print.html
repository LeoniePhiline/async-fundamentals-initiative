<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>async fn fundamentals initiative</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">👋 Welcome</a></li><li class="chapter-item "><a href="CHARTER.html">📜 Charter</a></li><li class="chapter-item "><a href="roadmap.html">🛣 Roadmap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="roadmap/mvp.html">MVP: Static async fn in traits</a></li></ol></li><li class="chapter-item "><a href="evaluation.html">🔬 Evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/executor-styles.html">Executor styles</a></li><li class="chapter-item "><a href="evaluation/scenarios.html">Reference scenarios</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/scenarios/background-logging.html">Background logging</a></li><li class="chapter-item "><a href="evaluation/scenarios/implementing-async-read.html">Implementing AsyncRead</a></li></ol></li><li class="chapter-item "><a href="evaluation/challenges.html">Challenges</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/challenges/bounding_futures.html">Bounding futures</a></li><li class="chapter-item "><a href="evaluation/challenges/naming_futures.html">Naming futures</a></li><li class="chapter-item "><a href="evaluation/challenges/dyn_traits.html">Dyn traits</a></li><li class="chapter-item "><a href="evaluation/challenges/bounding_async_drop.html">Bounding async drop</a></li><li class="chapter-item "><a href="evaluation/challenges/guaranteeing_async_drop.html">Guaranteeing async drop</a></li><li class="chapter-item "><a href="evaluation/challenges/implicit_await_with_async_drop.html">Implicit await with async drop</a></li></ol></li><li class="chapter-item "><a href="evaluation/design.html">Design documents</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/design/implied_send.html">Implied Send</a></li><li class="chapter-item "><a href="evaluation/design/trait_multiplication.html">Trait multiplication</a></li><li class="chapter-item "><a href="evaluation/design/inline_async_fn.html">Inline async fn</a></li><li class="chapter-item "><a href="evaluation/design/custom_dyn_impls.html">Custom dyn impls</a></li><li class="chapter-item "><a href="evaluation/design/auto_traits_consider_async_drop.html">Auto traits consider AsyncDrop</a></li><li class="chapter-item "><a href="evaluation/design/simple_names.html">Simple names</a></li></ol></li></ol></li><li class="chapter-item "><a href="explainer.html">📚 Explainer</a></li><li class="chapter-item "><a href="RFC.html">✨ RFC</a></li><li class="chapter-item "><a href="design-discussions/index.html">💬 Design discussions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/static_async_trait.html">💬 Static async trait</a></li><li class="chapter-item "><a href="design-discussions/impl_trait_in_traits.html">💬 impl Trait in traits</a></li><li class="chapter-item "><a href="design-discussions/dyn_async_trait.html">💬 Dyn async trait</a></li><li class="chapter-item "><a href="design-discussions/dyn_trait.html">💤 Dyn trait</a></li><li class="chapter-item "><a href="design-discussions/async_drop.html">💤 Async drop</a></li><li class="chapter-item "><a href="design-discussions/async_closures.html">💤 Async closures</a></li></ol></li><li class="chapter-item "><a href="FAQ.html">😕 FAQ</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">async fn fundamentals initiative</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/async-fundamentals-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="async-fundamentals-initiative"><a class="header" href="#async-fundamentals-initiative">async fundamentals initiative</a></h1>
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the async fundamentals <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>, part of the wg-async-foundations <a href="https://rust-lang.github.io/wg-async-foundations/vision.html">vision process</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>.</p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>This is an <strong>umbrella initiative</strong> and, as such, it covers a number of subprojects.</p>
<p>See the <a href="./roadmap.html">roadmap</a> for a list of individual milestones and their status.</p>
<table><thead><tr><th>Subproject</th><th>Issue</th><th>Progress</th><th>State</th><th><a href="https://lang-team.rust-lang.org/initiatives/process/stages.html">Stage</a></th></tr></thead><tbody>
<tr><td>async fn</td><td><a href="https://github.com/rust-lang/rust/issues/50547">#50547</a></td><td>▰▰▰▰▰▰</td><td>✅</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td></tr>
<tr><td>static async fn in trait</td><td>–</td><td>▰▱▱▱▱▱</td><td>🦀</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td></tr>
<tr><td>dyn async fn in trait</td><td>–</td><td>▰▱▱▱▱▱</td><td>🦀</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td></tr>
<tr><td>async drop</td><td>–</td><td>▰▱▱▱▱▱</td><td>🦀</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td></tr>
<tr><td>async closures</td><td>–</td><td>▰▱▱▱▱▱</td><td>💤</td><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td></tr>
</tbody></table>
<!-- TODO: Fill these in
[Proposal issue]: (https://github.com/rust-lang/lang-team/)
[Tracking issue]: https://github.com/rust-lang/rust/
-->
<p>Key:</p>
<ul>
<li>✅ – phase complete</li>
<li>🦀 – phase in progress</li>
<li>💤 – phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-discussions">design discussions</a> first.</li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-discussions">design discussions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please <a href="https://github.com/rust-lang/async-fundamentals-initiative/issues/new?labels=experience-report&amp;template=experience-report.md">open a &quot;experience report&quot; issue</a>.</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<!-- Should there be a dedicated team? -->
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-async-fn-fundamentals-charter"><a class="header" href="#-async-fn-fundamentals-charter">📜 async fn fundamentals Charter</a></h1>
<!--
 Provide an introduction summarising the goals and motivation behind your
 initiative.
-->
<p>This initiative is part of the wg-async-foundations <a href="https://rust-lang.github.io/wg-async-foundations/vision.html">vision process</a>.</p>
<ul>
<li>Able to write <code>async fn</code> in traits and trait impls
<ul>
<li>Able to easily declare that <code>T: Trait + Send</code> where &quot;every async fn in <code>Trait</code> returns a <code>Send</code> future&quot;</li>
<li>Traits that use <code>async fn</code> can still be <a href="./design-discussions/dyn_async_trait.html">dyn safe</a> though some tuning may be required</li>
<li>Async functions in traits desugar to <a href="./design-discussions/impl_trait_in_traits.html">impl Trait in traits</a></li>
</ul>
</li>
<li>Able to write <a href="./design-discussions/async_drop.html">&quot;async fn drop&quot;</a> to declare that the destructor may await</li>
<li>Support for <a href="./design-discussions/async_closures.html">async closures</a></li>
</ul>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>TODO</p>
<!--
Copy and paste the proposal into here.

Feel free to move some elements, like design questions that came up,
into the approriate section.
-->
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/tmandry">tmandry</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">Liaison</a></td><td><a href="https://github.com/nikomatsakis">nikomatsakis</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-fn-fundamentals"><a class="header" href="#async-fn-fundamentals">Async fn fundamentals</a></h1>
<p>This initiative is part of the overal <a href="https://rust-lang.github.io/wg-async-foundations/vision/roadmap.html">async vision roadmap</a>.</p>
<h2 id="impact"><a class="header" href="#impact">Impact</a></h2>
<ul>
<li>Able to write <code>async fn</code> in traits and trait impls
<ul>
<li>Able to easily declare that <code>T: Trait + Send</code> where &quot;every async fn in <code>Trait</code> returns a <code>Send</code> future&quot;</li>
<li>Traits that use <code>async fn</code> can still be <a href="./design-discussions/dyn_async_trait.html">dyn safe</a> though some tuning may be required</li>
<li>Async functions in traits desugar to <a href="./design-discussions/impl_trait_in_traits.html">impl Trait in traits</a></li>
</ul>
</li>
<li>Able to write <a href="./design-discussions/async_drop.html">&quot;async fn drop&quot;</a> to declare that the destructor may await</li>
<li>Support for <a href="./design-discussions/async_closures.html">async closures</a></li>
</ul>
<h2 id="milestones"><a class="header" href="#milestones">Milestones</a></h2>
<table><thead><tr><th>Milestone</th><th>State</th><th>Key participants</th></tr></thead><tbody>
<tr><td>Author <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/evaluations.html">evaluation doc</a> for <a href="./design-discussions/static_async_trait.html">static async trait</a></td><td>🦀</td><td><a href="https://github.com/tmandry/">tmandry</a></td></tr>
<tr><td>Author <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/evaluations.html">evaluation doc</a> for <a href="./design-discussions/dyn_async_trait.html">dyn async trait</a></td><td>🦀</td><td><a href="https://github.com/tmandry/">tmandry</a></td></tr>
<tr><td>Author <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/evaluations.html">evaluation doc</a> for <a href="./design-discussions/async_drop.html">async drop</a></td><td>🦀</td><td><a href="https://github.com/tmandry/">tmandry</a></td></tr>
<tr><td>Author <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/evaluations.html">evaluation doc</a> for <a href="./design-discussions/impl_trait_in_traits.html">impl Trait in traits</a></td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilize</a> <a href="https://github.com/rust-lang/rust/issues/63063">type alias impl trait</a></td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilize</a> <a href="https://github.com/rust-lang/generic-associated-types-initiative">generic associated types</a></td><td>💤</td><td></td></tr>
<tr><td>Author RFC for async fn in traits</td><td>💤</td><td></td></tr>
<tr><td>Author <a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/evaluations.html">evaluation doc</a> for <a href="./design-discussions/async_closures.html">async closures</a></td><td>💤</td><td></td></tr>
<tr><td>Author RFC for async fn in traits</td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature_complete.html">Feature complete</a> for async fn in traits</td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature_complete.html">Feature complete</a> for <a href="./design-discussions/impl_trait_in_traits.html">impl Trait in traits</a></td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature_complete.html">Feature complete</a> for <a href="./design-discussions/async_drop.html">async drop</a></td><td>💤</td><td></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature_complete.html">Feature complete</a> for <a href="./design-discussions/async_closures.html">async closures</a></td><td>💤</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvp-static-async-fn-in-traits"><a class="header" href="#mvp-static-async-fn-in-traits">MVP: Static async fn in traits</a></h1>
<p>This section defines an initial <strong>minimum viable product</strong> (MVP). This MVP is meant to be a subset of async fns in traits that can be implemented and stabilized quickly.</p>
<h2 id="in-a-nutshell"><a class="header" href="#in-a-nutshell">In a nutshell</a></h2>
<ul>
<li>In traits, <code>async fn foo(&amp;self)</code> desugars to
<ul>
<li>an anonymous associated type <code>type Foo&lt;'me&gt;: Future&lt;Output = ()&gt;</code> (as this type is anonymous, users cannot actually name it; the name <code>Foo</code> here is for demonstrative purposes only)</li>
<li>a function <code>fn foo(&amp;self) -&gt; Self::Foo&lt;'_&gt;</code> that returns this future</li>
</ul>
</li>
<li>In impls, <code>async fn foo(&amp;self)</code> desugars to
<ul>
<li>a value for the anonymous associated type <code>type Foo&lt;'me&gt; = impl Future&lt;Output = ()&gt;</code></li>
<li>a function <code>fn foo(&amp;self) -&gt; Self::Foo&lt;'_&gt; { async move { ... } }</code></li>
</ul>
</li>
<li>If the trait used <code>async fn</code>, then the impl must use <code>async fn</code> (and vice versa)</li>
<li>Traits that use <code>async fn</code> are <em>not</em> dyn safe
<ul>
<li>In the MVP, traits using async fn can only be used with <code>impl Trait</code> or generics</li>
</ul>
</li>
</ul>
<h2 id="what-this-enables"><a class="header" href="#what-this-enables">What this enables</a></h2>
<ul>
<li>The MVP is sufficient for projects like <a href="https://github.com/embassy-rs/embassy">embassy</a>, which already model async fns in traits in this way.</li>
<li>TODO: Once we have a list of stakeholders, try to get a sense for how many uses of <a href="https://crates.io/crates/async-trait"><code>async-trait</code></a> could be replaced</li>
</ul>
<h2 id="notable-limitations-and-workarounds"><a class="header" href="#notable-limitations-and-workarounds">Notable limitations and workarounds</a></h2>
<ul>
<li>No support for <a href="roadmap/../evaluation/challenges/dyn_traits.html"><code>dyn</code></a>
<ul>
<li>This is a fundamental limitation; the only workaround is to use <a href="https://crates.io/crates/async-trait"><code>async-trait</code></a></li>
</ul>
</li>
<li>No ability to name the resulting futures:
<ul>
<li>This means that one cannot build non-generic adapters that reference those futures.</li>
<li>Workaround: define a function alongside the impl and use a TAIT for its return type</li>
</ul>
</li>
<li>No ability to bound the resulting futures (e.g., to require that they are <code>Send</code>)
<ul>
<li>This rules out certain use cases when using work-stealing <a href="roadmap/../evaluation/executor-styles.html">executor styles</a>, such as the <a href="roadmap/../evaluation/scenarios/background-logging.html">background logging</a> scenario. Note that many other uses of async fn in traits will likely work fine even with a work-stealing executor: the only limitation is that one cannot write generic code that invokes <code>spawn</code>.</li>
<li>Workaround: do the desugaring manually when required, which would give a name for the relevant future.</li>
</ul>
</li>
</ul>
<h2 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation plan</a></h2>
<ul>
<li>This MVP relies on having <a href="https://rust-lang.github.io/generic-associated-types-initiative/">generic associated types</a> and <a href="https://rust-lang.github.io/impl-trait-initiative/">type alias impl trait</a>, but they are making good progress.</li>
<li>Otherwise, the implementation is a straightforward desugaring, similar to how inherent async fns are implemented</li>
<li>We may wish to also ship a variant of the <a href="https://crates.io/crates/async-trait"><code>async-trait</code></a> macro that lets people easily experiment with this feature</li>
</ul>
<h2 id="forward-compatibility"><a class="header" href="#forward-compatibility">Forward compatibility</a></h2>
<p>The MVP sidesteps a number of the <a href="roadmap/../evaluation/challenges.html">more challenging design problems</a>. It should be forwards compatible with:</p>
<ul>
<li>Adding support for <a href="roadmap/../evaluation/challenges/dyn_traits.html"><code>dyn</code></a> traits later</li>
<li>Adding a mechanism to <a href="roadmap/../evaluation/challenges/bounding_futures.html">bound the resulting futures</a>
<ul>
<li><strong>WARNING:</strong> It is NOT compatible with <a href="roadmap/../evaluation/design/implied_send.html">Implied Send</a>, however!</li>
</ul>
</li>
<li>Adding a mechanism to <a href="roadmap/../evaluation/challenges/naming_futures.html">name the resulting futures</a>
<ul>
<li>The futures added here are anonymous, and we can always add explicit names later.</li>
<li><em>If</em> we were to <a href="roadmap/../evaluation/design/simple_names.html">name the resulting futures after the methods</a>, and users had existing traits that used those same names already, this could present a conflict, but one that could be resolved.</li>
</ul>
</li>
<li>Supporting and bounding <a href="roadmap/../evaluation/challenges/bounding_async_drop.html">async drop</a>
<ul>
<li>This trait will not exist yet with the MVP, and supporting <code>async fn</code> doesn't enable anything fundamental that we don't have to solve anyway.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-evaluation"><a class="header" href="#-evaluation">🔬 Evaluation</a></h1>
<blockquote>
<p>The <em>evaluation</em> surveys the various design approaches that are under consideration.
It is not required for all initiatives, only those that begin with a problem statement
but without a clear picture of the best solution. Often the evaluation will refer to topics
in the <a href="./design-discussions/README.html">design-discussions</a> for more detailed consideration.</p>
</blockquote>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<h3 id="write-async-fn-in-traits-impls"><a class="header" href="#write-async-fn-in-traits-impls">Write async fn in traits, impls</a></h3>
<p>The goal of the impact is to enable users to write <code>async fn</code> in traits and impls in a natural way. As a simple example, we would like to support the ability to write an <code>async fn</code> in any trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Connection {
    async fn open(&amp;mut self);
    async fn send(&amp;mut self);
    async fn close(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>Along with the corresponding impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Connection for MyConnection {
    async fn open(&amp;mut self) {
        ...
    }

    async fn send(&amp;mut self) {
        ...
    }

    async fn close(&amp;mut self) {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The goal in general is that <code>async fn</code> can be used in traits as widely as possible:</p>
<ul>
<li>for foundational traits, like reading, writing, and iteration;</li>
<li>for async closures;</li>
<li>for async drop, which is built in to the language;</li>
<li>in <code>dyn</code> values, which introduce some particular complications;</li>
<li>in libraries, for all the usual reasons one uses traits;</li>
<li>in ordinary programs, using all manner of executors.</li>
</ul>
<h3 id="support-async-drop"><a class="header" href="#support-async-drop">Support async drop</a></h3>
<p>One particular trait worth discussing is the <code>Drop</code> trait. We would like to support &quot;async drop&quot;, which means the ability to await things during drop:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncDrop {
    async fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>Like <code>Drop</code>, the <code>AsyncDrop</code> trait would be </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor-styles-and-send-bounds"><a class="header" href="#executor-styles-and-send-bounds">Executor styles and Send bounds</a></h1>
<p>One key aspect of async fn in traits has to do with how to communicate <code>Send</code> bounds needed to spawn tasks. The key question is roughly &quot;what send bounds are required to safely spawn a task?&quot;</p>
<ul>
<li>A <strong>single threaded</strong> executor runs all tasks on a single thread. 
<ul>
<li>In this scenario, nothing has to be <code>Send</code>.</li>
<li>Example: <a href="https://docs.rs/tokio/1.11.0/tokio/task/fn.spawn_local.html">tokio::spawn_local</a></li>
</ul>
</li>
<li>A <strong>thread per core</strong> executor selects a thread to run a task when the task is spawned, but never migrates tasks between threads. This can be very efficient because the runtimes never need to communicate across threads except to spawn new tasks. 
<ul>
<li>In this scenario, the &quot;initial state&quot; must be <code>Send</code> but not the future once it begins executing.</li>
<li>Example: <a href="https://docs.rs/glommio/0.5.1/glommio/struct.LocalExecutorBuilder.html#method.spawn">glommio::spawn</a></li>
</ul>
</li>
<li>A <strong>work-stealing</strong> executor can move tasks between threads even mid-execution. 
<ul>
<li>In this scenario, the future must be <code>Send</code> at all times (or we have to rule out the ability to have leaks of data out from the future, which we don't have yet).</li>
<li>Example: <a href="https://docs.rs/glommio/0.5.1/glommio/struct.LocalExecutorBuilder.html#method.spawn">tokio::spawn</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-scenarios"><a class="header" href="#reference-scenarios">Reference scenarios</a></h1>
<ul>
<li><a href="evaluation/./scenarios/background-logging.html">Logging in the background</a></li>
<li><a href="evaluation/./scenarios/implementing-async-read.html">Implementing AsyncRead</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background-logging"><a class="header" href="#background-logging">Background logging</a></h1>
<p>In this scenario, the <code>start_writing_logs</code> function takes an async iterable and spawns out a new task. This task will pull items from the iterator and send them to some server:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncIterator {
    type Item;
    async fn next(&amp;mut self) -&gt; Self::Item;
}

// Starts a task that will write out the logs in the background
async fn start_writing_logs(
    logs: impl AsyncIterator&lt;Item = String&gt; + 'static
) {
    spawn(async move || {
        while let Some(log) = logs.next().await {
            send_to_serve(log).await;
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>The precise signature and requirements for the <code>spawn</code> function here will depend on what <a href="evaluation/scenarios/../executor-styles.html">kind of executor</a> you are using, so let's consider each case but let's consider each case separately.</p>
<p>One note: in [tokio] and other existing executors, the <code>spawn</code> function takes a future, not an async closure. We are using a closure here because that is more analogous to the synchronous signature, but also because it enables a distinction between the <em>initial state</em> and the future that runs.</p>
<h2 id="thread-local-executor"><a class="header" href="#thread-local-executor">Thread-local executor</a></h2>
<p>This is the easy case. Nothing has to be <code>Send</code>.</p>
<h2 id="work-stealing-executor"><a class="header" href="#work-stealing-executor">Work-stealing executor</a></h2>
<p>In this case, the spawn function will require both that the initial closure itself is <code>Send</code> and that the future it returns is <code>Send</code> (so that it can be moved from place to place as code executes).</p>
<p>We don't have a good way to express this today! The problem is that there is a future that results from calling <code>logs.next()</code>, let's call it <code>F</code>. The future to be <em>spawned</em> has to be sure that <code>F: Send</code>. There isn't a good way to do this today, and even explaining the problem is surprisingly hard. Here is a &quot;desugared version&quot; of the program that shows what is needed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncIterator {
    type Item;
    type NextFuture: Future&lt;Output = Self::Item&gt;;

    fn next(&amp;mut self) -&gt; impl Self::NextFuture;
}

// Starts a task that will write out the logs in the background
async fn start_writing_logs&lt;I&gt;(
    logs: I
) 
where
    I: AsyncIterator&lt;Item = String&gt; + 'static + Send,
    I::NextFuture: Send,
{
    spawn(async move || {
        while let Some(log) = logs.next().await {
            send_to_serve(log).await;
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>(With <a href="https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html">RFC 2289</a>, you could write <code>logs: impl AsyncIterator&lt;Item = String, NextFuture: Send&gt; + Send</code>, which is more compact, but still awkward.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-asyncread"><a class="header" href="#implementing-asyncread">Implementing AsyncRead</a></h1>
<p><code>AsyncRead</code> is being used here as a &quot;stand-in&quot; for some widely used trait that appears in the standard library. The details of the trait are not important.</p>
<h2 id="self-is-send"><a class="header" href="#self-is-send">Self is send</a></h2>
<p>In this scenario, the Self type being used to implement is sendable, but the actual future that is created is not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MySocketBuddy {
    x: u32
}

impl AsyncRead for MySocketBuddy {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        let ssh_key = Rc::new(vec![....]);
        do_some_stuff(ssh_key.clone());
        something_else(self.x).await;
    }
    // ERROR: `ssh_key` is live over an await;
    //        Self implements Send
    //        therefore resulting future must implement Send
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="self-is-not-send"><a class="header" href="#self-is-not-send">Self is not send</a></h2>
<p>In this scenario, the Self type being used to implement is not sendable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MySocketBuddy {
    x: u32,
    ssh_key: Rc&lt;Vec&lt;u8&gt;&gt;,
}

impl AsyncRead for MySocketBuddy {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        do_some_stuff(self.ssh_key.clone());
        something_else(self.x).await;
    }
    // OK
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="challenges"><a class="header" href="#challenges">Challenges</a></h1>
<p>This section describes the <em>challenges</em> that we need to find solutions for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounding-futures"><a class="header" href="#bounding-futures">Bounding futures</a></h1>
<p>The challenge is to be able to concisely and intuitively bound the <em>futures resulting from async fn calls</em>, as described in the <a href="evaluation/challenges/../scenarios/background-logging.html">Background Logging</a> scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming-futures"><a class="header" href="#naming-futures">Naming futures</a></h1>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>Seems unlikely to be adopted. Doesn't <em>feel</em> right, and doesn't give any expanded abilities, such as the ability to name the future type.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The challenge is to be able to name the future that results from a particular async function. This can be used, for example, when naming future types, or perhaps as part of <a href="evaluation/challenges/./bounding_futures.html">bounding futures</a>.</p>
<p>It is likely that this problem is best solved in the context of the <a href="https://rust-lang.github.io/impl-trait-initiative/">impl trait initiative</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-traits"><a class="header" href="#dyn-traits">Dyn traits</a></h1>
<p>Supporting <code>dyn Trait</code> when <code>Trait</code> contains an <code>async fn</code> is challenging:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    async fn foo(&amp;self);
}

impl Trait for TypeA {
    async fn foo(&amp;self);
}

impl Trait for TypeB { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Consider the desugared form of this trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Foo&lt;'s&gt;: Future&lt;Output = ()&gt; + 's;

    fn foo(&amp;self) -&gt; Self::Foo&lt;'_&gt;;
}

impl Trait for TypeA {
    type Foo&lt;'s&gt; = impl Future&lt;Output = ()&gt; + 's;

    fn foo(&amp;self) -&gt; Self::Foo&lt;'_&gt; {
        async move { ... } // has some unique future type F_A
    }
}

impl Trait for TypeB { ... }
<span class="boring">}
</span></code></pre></pre>
<p>The primary challenge to using <code>dyn Trait</code> in today's Rust is that <strong><code>dyn Trait</code> today must list the values of all associated types</strong>. This means you would have to write <code>dyn for&lt;'s&gt; Trait&lt;Foo&lt;'s&gt; = XXX&gt;</code> where <code>XXX</code> is the future type defined by the impl, such as <code>F_A</code>. This is not only verbose (or impossible), it also uniquely ties the <code>dyn Trait</code> to a particular impl, defeating the whole point of <code>dyn Trait</code>.</p>
<p>For this reason, the <code>async_trait</code> crate models all futures as <code>Box&lt;dyn Future&lt;...&gt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
trait Trait {
    async fn foo(&amp;self);
}

// desugars to

trait Trait {
    fn foo(&amp;self) -&gt; Box&lt;dyn Future&lt;Output = ()&gt; + Send + '_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This compiles, but it has downsides:</p>
<ul>
<li>Allocation is required, <em>even when not using dyn Trait</em>.</li>
<li>The user must state up front whether <code>Box&lt;dyn Future...&gt;</code> is <code>Send</code> or not.
<ul>
<li>In <code>async_trait</code>, this is declared by writing <code>#[async_future(?Send)]</code> if desired.</li>
</ul>
</li>
</ul>
<h2 id="desiderata"><a class="header" href="#desiderata">Desiderata</a></h2>
<p>Here are some of the general constraints:</p>
<ul>
<li>The ability to use <code>async fn</code> in a trait without allocation</li>
<li>When using a <code>dyn Trait</code>, the type of the future must be the same for all impls
<ul>
<li>This implies a <code>Box</code> or other pointer indirection, or something like <a href="evaluation/challenges/../design/inline_async_fn.html">inline async fn</a>.</li>
</ul>
</li>
<li>It would be nice if it were possible to use <code>dyn Trait</code> in an embedded context (without access to <code>Box</code>)
<ul>
<li>This will not be possible &quot;in general&quot;, but it could be possible for particular traits, such as <code>AsyncIterator</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounding-async-drop"><a class="header" href="#bounding-async-drop">Bounding async drop</a></h1>
<p>As a special case of the <a href="evaluation/challenges/./bounding_futures.html">bounding futures</a> problem, we must consider <code>AsyncDrop</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo&lt;T&gt;(t: T) {
    runtime::sleep(22).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>The type of <code>foo(t)</code> is going to be a future type like <code>FooFuture&lt;T&gt;</code>. This type will also include the types of all futures that get awaited (e.g., the return value of <code>runtime::sleep(22)</code> in this case). But in the case of <code>T</code>, we don't yet know what <code>T</code> is, and if it should happen to implement <code>AsyncDrop</code>, then there is an <a href="evaluation/challenges/./implicit_await_with_async_drop.html">&quot;implicit await&quot;</a> of that future. We have to ensure that the contents of that future are taken into account when we determine if <code>FooFuture&lt;T&gt;: Send</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guaranteeing-async-drop"><a class="header" href="#guaranteeing-async-drop">Guaranteeing async drop</a></h1>
<p>One challenge with <code>AsyncDrop</code> is that we have no guarantee that it will be used. For any type <code>MyStruct</code> that implements <code>AsyncDrop</code>, it is always possible in Rust today to drop an instance of <code>MyStruct</code> in synchronous code. In that case, we cannot run the async drop. What should we do?</p>
<p>Obvious alternatives:</p>
<ul>
<li>Panic or abort</li>
<li>Use some form of &quot;block on&quot; or other default executor to execute the asynchronous await</li>
<li>Extend Rust in some way to prevent this condition.</li>
</ul>
<p>We can also mitigate this danger through lints (e.g., dropping value which implements AsyncDrop).</p>
<p>Some types may implement both synchronous and asynchronous drop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-await-with-async-drop"><a class="header" href="#implicit-await-with-async-drop">Implicit await with async drop</a></h1>
<p>Consider this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(input: &amp;QueryInput) -&gt; anyhow::Result&lt;()&gt; {
    let db = DatabaseHandle::connect().await;
    let query = assemble_query(&amp;input)?;
    let results = db.perform_query(query).await;
    while let Some(result) = results.next().await? {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let us assume that <code>DatabaseHandle</code> implements <code>AsyncDrop</code> to close the connection. There are numerous points here where <code>db</code> could be dropped (e.g., each use of <code>?</code>). At each of those points, there is effectively an implicit <code>await</code> similar to <code>AsyncDrop::async_drop(db).await</code>. It seems clear that users should not be required to manually write those things, but it is also a weakening of the existing <code>.await</code> contract (that all blocking points are visible).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-documents"><a class="header" href="#design-documents">Design documents</a></h1>
<p>This section contains detailed design documents aimed at various challenges.</p>
<table><thead><tr><th>Document</th><th>Challenges addressed</th><th>Status</th></tr></thead><tbody>
<tr><td><a href="evaluation/./design/implied_send.html">Implied Send</a></td><td><a href="evaluation/./challenges/bounding_futures.html">Bounding futures</a></td><td>❌</td></tr>
<tr><td><a href="evaluation/./design/trait_multiplication.html">Trait multiplication</a></td><td><a href="evaluation/./challenges/bounding_futures.html">Bounding futures</a></td><td>🤔</td></tr>
<tr><td><a href="evaluation/./design/inline_async_fn.html">Inline async fn</a></td><td><a href="evaluation/./challenges/bounding_futures.html">Bounding futures</a>, <a href="evaluation/./challenges/dyn_traits.html">Dyn traits</a> (partially)</td><td>🤔</td></tr>
<tr><td><a href="evaluation/./design/custom_dyn_impls.html">Custom dyn impls</a></td><td><a href="evaluation/./challenges/dyn_traits.html">Dyn traits</a></td><td>🤔</td></tr>
<tr><td>[Auto traits consider AsyncDrop]</td><td>[Bounding drop]</td><td>🤔</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implied-send"><a class="header" href="#implied-send">Implied Send</a></h1>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>❌ Rejected. This idea can be quite <a href="https://rustacean-principles.netlify.app/how_rust_empowers/productive.html">productive</a>, but it is not <a href="https://rustacean-principles.netlify.app/how_rust_empowers/versatile.html">versatile</a> (it rules out important use cases) and it is not <a href="https://rustacean-principles.netlify.app/how_rust_empowers/supportive.html">supportive</a> (it is confusing).</p>
<p>(FIXME: I think the principles aren't quite capturing the constriants here! We should adjust.)</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Targets the <a href="evaluation/design/../challenges/bounding_futures.html">bounding futures</a> challenge.</p>
<p>The core idea of <strong>&quot;implied Send&quot;</strong> is to say that, by default at least, the future that results from an <code>async fn</code> must be <code>Send</code> if the <code>Self</code> type that implements the trait is <code>Send</code>.</p>
<p>In Chalk terms, you can think of this as a bound like </p>
<pre><code>if (Implemented(Self: Send)) { 
    Implemented(Future: Send)
}
</code></pre>
<p>Mathematically, this can be read as <code>Implemented(Self: Send) =&gt; Implemented(Future: Send)</code>. In other words, if you assume that <code>Self: Send</code>, then you can show that <code>Future: Send</code>.</p>
<h2 id="desugared-semantics"><a class="header" href="#desugared-semantics">Desugared semantics</a></h2>
<p>If we extended the language with <code>if</code> bounds a la Chalk, then the desugared semantics of &quot;implied send&quot; would be something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncIterator {
    type Item;
    type NextFuture: Future&lt;Output = Self::Item&gt;
                   + if (Self: Send) { Send };

    fn next(&amp;mut self) -&gt; impl Self::NextFuture;
}
<span class="boring">}
</span></code></pre></pre>
<p>As a result, when you implement <code>AsyncIterator</code>, the compiler will check that your futures are <code>Send</code> if your input type is assumed to be <code>Send</code>.</p>
<h2 id="whats-great-about-this"><a class="header" href="#whats-great-about-this">What's great about this</a></h2>
<p>The cool thing about this is that if you have a bound like <code>T: AsyncIterator + Send</code>, that automatically implies that any futures that may result from calling <code>AsyncIterator</code> methods will also be <code>Send</code>. Therefore, the <a href="evaluation/design/../scenarios/background-logging.html">background logging</a> scenario works like this, which is perfect for a <a href="evaluation/design/../executor-styles.html">work stealing</a> executor style.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn start_writing_logs(
    logs: impl AsyncIterator&lt;Item = String&gt; + Send + 'static
) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="whats-not-so-great"><a class="header" href="#whats-not-so-great">What's not so great</a></h2>
<h3 id="negative-reasoning-semver-interactions-how-to-prove"><a class="header" href="#negative-reasoning-semver-interactions-how-to-prove">Negative reasoning: Semver interactions, how to prove</a></h3>
<p>In this proposal, when one implements an async trait for some concrete type, the compiler would presumably have to first check whether that type implements <code>Send</code>. If not, then it is ok if your futures do not implement <code>Send</code>. That kind of negative reasoning is actually quite tricky -- it has potential semver implications, for example -- although auto traits are more amenable to it than other things, since they already interact with semver in complex ways.</p>
<p>In fact, if we use the standard approach for proving implication goals, the setup would not work at all. The typical approach to proving an implication goal like <code>P =&gt; Q</code> is to assume <code>P</code> is true and then try to prove <code>Q</code>. But that would mean that we would just wind up assuming that the <code>Self</code> type is <code>Send</code> and trying to use that to prove the resulting <code>Future</code> is <code>Send</code>, not <em>checking</em> whether <code>Self</code> is <code>Send</code> to decide.</p>
<h3 id="not-analogous-to-async-fn-outside-of-traits"><a class="header" href="#not-analogous-to-async-fn-outside-of-traits">Not analogous to async fn outside of traits</a></h3>
<p>With inherent async functions, we don't check whether the resulting future is <code>Send</code> right away. Instead, we remember what state it has access to, and then if there is some part of the code that requires a future to be <code>Send</code>, we check <em>then</em>. </p>
<p>But this &quot;implied send&quot; approach is different: the trait is effectively declaring up front that async functions must be send (if the Self is send, at least), and so you wind up with errors at the <em>impl</em>. This is true regardless of whether the future ever winds up being used in a spawn.</p>
<p>The concern here is not <em>precisely</em> that the result is too strict (that's covered in the next bullet), but rather that it will be surprising behavior for people. They'll have a hard time understanding why they get errors about <code>Send</code> in some cases but not others.</p>
<h3 id="stricter-than-is-required-for-non-work-stealing-a-hrefevaluationdesignexecutor-styleshtmlexecutor-stylesa"><a class="header" href="#stricter-than-is-required-for-non-work-stealing-a-hrefevaluationdesignexecutor-styleshtmlexecutor-stylesa">Stricter than is required for non-work-stealing <a href="evaluation/design/../executor-styles.html">executor styles</a></a></h3>
<p>Building on the previous point, this approach can be stricter than what is required when not using a work stealing <a href="evaluation/design/../executor-styles.html">executor style</a>.</p>
<p>As an example, consider a case where you are coding in a thread-local setting, and you have a struct like the following</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyCustomIterator {
    start_index: u32
}
<span class="boring">}
</span></code></pre></pre>
<p>Now you try to implement <code>AsyncIterator</code>. You know your code is thread-local, so you decide to use some <code>Rc</code> data in the process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsyncIterator for MyCustomIterator {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        let ssh_key = Rc::new(vec![....]);
        do_some_stuff(ssh_key.clone());
        something_else(self.start_index).await;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>But now you get a compilation error:</p>
<pre><code>error: `read` must be `Send`, since `MyCustomIterator` is `Send`
</code></pre>
<p>Frustrating!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-multiplication"><a class="header" href="#trait-multiplication">Trait multiplication</a></h1>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>Seems unlikely to be adopted, but may be the seed of a better idea</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Introduce a new form of bound, trait <em>multiplication</em>. One can write <code>T: Iterator * Send</code> and it means <code>T: Iterator&lt;Item: Send&gt; + Send</code> (using the notation from <a href="https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html">RFC 2289</a>). More generally, <code>Foo * Bar</code> means <code>Foo + Bar</code> but also that <code>Foo::Assoc: Bar</code> for each associated type <code>Assoc</code> defined in <code>Foo</code> (including anonymous ones defined by async functions).</p>
<h2 id="whats-great-about-this-1"><a class="header" href="#whats-great-about-this-1">What's great about this</a></h2>
<p>The cool thing about this is that it means that <strong>the check whether things are Send occurs exactly when it is needed, and not at the definition site</strong>. This makes async functions in trait behave more analogously with ordinary impls. (<a href="evaluation/design/./implied_send.html#not-analogous-to-async-fn-outside-of-traits">In contrast to implied bounds</a>.)</p>
<p>With this proposal, the <a href="evaluation/design/../scenarios/background-logging.html">background logging</a> scenario would play out differently depending on the <a href="evaluation/design/../executor-styles.html">executor style</a> being used:</p>
<ul>
<li>Thread-local: <code>logs: impl AsyncIterator&lt;Item = String&gt; + 'static</code></li>
<li>Thread per core: <code>logs: impl AsyncIterator&lt;Item = String&gt; + Send + 'static</code></li>
<li>Work stealing: <code>logs: impl AsyncIterator&lt;Item = String&gt; * Send + 'static</code></li>
</ul>
<p>The key observation here is that <code>+ Send</code> only tells you whether the <em>initial value</em> (here, <code>logs</code>) is <code>Send</code>. The <code>* Send</code> is needed to say &quot;and the futures resulting from this trait are Send&quot;, which is needed in work-stealing sceanrios.</p>
<h2 id="whats-not-so-great-about-this"><a class="header" href="#whats-not-so-great-about-this">What's not so great about this</a></h2>
<h3 id="complex"><a class="header" href="#complex">Complex</a></h3>
<p>The distinction between <code>+</code> and <code>*</code> is subtle but crucial. It's going to be a new thing to learn and it just makes the trait system feel that much more complex overall.</p>
<h3 id="reptitive-for-multiple-traits"><a class="header" href="#reptitive-for-multiple-traits">Reptitive for multiple traits</a></h3>
<p>If you had a number of async traits, you would need <code>* Send</code> for each one:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait1 {
    async fn method1(&amp;self);
}

trait Trait2 {
    async fn method2(&amp;self);
}

async fn foo&lt;T&gt;()
where
    T: Send * (Trait1 + Trait2)
{

}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-async-fn"><a class="header" href="#inline-async-fn">Inline async fn</a></h1>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>Seems unlikely to be adopted, but may be the seed of a better idea</p>
<h2 id="status-quo"><a class="header" href="#status-quo">Status quo</a></h2>
<p>Until now, the only way to make an &quot;async trait&quot; be dyn-safe was to use a manual poll method. The <a href="https://docs.rs/futures/0.3.15/futures/io/trait.AsyncRead.html"><code>AsyncRead</code></a> trait in futures, for example, is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsyncRead {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;mut [u8]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;

    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    
    fn poll_read_vectored(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        bufs: &amp;mut [IoSliceMut&lt;'_&gt;]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementing these traits is a significant hurdle, as it requires the use of <code>Pin</code>. It also means that people cannot leverage <code>.await</code> syntax or other niceties that they are accustomed to. (See <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_hates_writing_a_stream.html">Alan hates writing a stream</a> for a narrative description.)</p>
<p>It would be nice if we could rework those traits to use <code>async fn</code>. Today that is only possible using the <code>async_trait</code> procedural macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt;;

    async fn poll_read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize, Error&gt;;

    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    
}
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, using async-trait has some downsides (see <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_needs_async_in_traits.html">Alan needs async in traits</a>). Most notably, the traits are rewritten to return a <code>Box&lt;dyn Future&gt;</code>. For many purposes, this is fine, but in the case of foundational traits like <code>AsyncRead</code>, <code>AsyncDrop</code>, <code>AsyncWrite</code>, it is a significant hurdle:</p>
<ul>
<li>These traits should be included in libcore and available to the no-std ecosystem, like <code>Read</code> and <code>Write</code>.</li>
<li>These traits are often on the performance &quot;hot path&quot; and forcing a memory allocation there could be significant for some applications.</li>
</ul>
<p>There are some other problems with the poll-based design. For example, the buffer supplied to <code>poll_read</code> can change in between invocations (and indeed existing adapters take advantage of this sometimes). This means that the traits cannot be used for <a href="https://github.com/rust-lang/wg-async-foundations/pull/207">zero copy</a>, although this is not the only hurdle.</p>
<h3 id="for-drop-especially-the-state-must-be-embedded-within-the-self-type"><a class="header" href="#for-drop-especially-the-state-must-be-embedded-within-the-self-type">For drop especially, the state must be embedded within the self type</a></h3>
<p>If we want to have an async version of drop, it is really important that it does not return a separate future, but only makes use of state embedded within the type. This is because we might have a <code>Box&lt;dyn Future&gt;</code> or some other type that implements <code>AsyncDrop</code>, but where we don't know the concrete type. We are going to want to be able to drop those, which implies that they will live on the stack, which implies that we have to know the contents of the resulting future to know if it is <code>Send</code>. </p>
<h2 id="problem-returning-a-future"><a class="header" href="#problem-returning-a-future">Problem: returning a future</a></h2>
<p>The fundamental problem that makes <code>async fn</code> not dyn-safe (and the reason that allocation is required) is that every implementation of <code>AsyncRead</code> requires different amounts of state. The future that is returned is basically an enumeration with fields for each value that may be live across an <code>await</code> point, and naturally that will vary per implementation. This means that code which doesn't know the precise type that it is working with cannot predict how much space that type will require. One solution is certainly boxing, which sidesteps the problem by returning a pointer to memory in the heap.</p>
<p>Using poll methods, as the existing traits do, sidesteps this in a different way: the poll methods basically require that any state that the <code>AsyncRead</code> impl requires across invocations of <code>poll</code> must be present within the <code>self</code> field itself. This is a perfectly valid solution for many applications, but figuring out that state and tracking it efficiently is tedious for users.</p>
<h2 id="proposal-inline-futures"><a class="header" href="#proposal-inline-futures">Proposal: &quot;inline&quot; futures</a></h2>
<p>The idea is to allow users to opt-in to &quot;inline futures&quot;. Users would write a <code>repr</code> attribute on traits that contain <code>async fn</code> methods (the attribute):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(inline_async)]
trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt;;
    
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The choice of <code>repr</code> is significant here:</p>
<ul>
<li>Like repr on a struct, this is meant to be used for things that affect how the code is compiled and its efficiency, but which don't affect the &quot;mental model&quot; of how the trait works.</li>
<li>Like repr on a struct, using repr may imply some limitations on the things you can do with the trait in order to achieve those benefits.</li>
</ul>
<p>When a trait is as <code>repr(inline_async)</code>, the state for all of its async functions will be added into the type that implements the trait (this attribute could potentially also be used per method). This does imply some key limitations:</p>
<ul>
<li><code>repr(inline_async)</code> traits can only be implemented on structs or enums defined in the current crate. This allows the compiler to append those fields into the layout of that struct or enum. </li>
<li><code>repr(inline_async)</code> traits can only contain <code>async fn</code> with <code>&amp;mut self</code> methods.</li>
</ul>
<h2 id="desugaring"><a class="header" href="#desugaring">Desugaring</a></h2>
<p>The desugaring for an <code>inline_async</code> function is different. Rather than an <code>async fn</code> becoming a type that returns an <code>impl Future</code>, the <code>async fn</code> always returns a value of a fixed type. This is a kind of variant on <a href="https://github.com/rust-lang/rust/issues/72302"><code>Future::PollFn</code></a>, which will simply invoke the <code>poll_read</code> function each time it is called. What we want is <em>something</em> like this, although this doesn't quite work (and relies on unstable features Niko doesn't love):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncRead {
    // Standard async fn desugaring, with a twist:
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Future::PollFn&lt;
        typeof(&lt;Self as AsyncRead&gt;::poll_read)
    &gt;;

    // 
    fn poll_read(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically the <code>read</code> method would</p>
<ul>
<li>initialize the state of the future and then</li>
<li>construct a <a href="https://github.com/rust-lang/rust/issues/72302"><code>Future::PollFn</code></a>-like struct that contains a pointer to the <code>poll_read</code> function. </li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="whats-wrong-with-that-desugaring"><a class="header" href="#whats-wrong-with-that-desugaring">What's wrong with that desugaring?</a></h3>
<p>The desugaring is pretty close. It has the nice property that, when invoked with a known type, the <code>Future::PollFn</code> dispatches statically the poll function, so there is no dynamic dispatch or loss of efficiency.</p>
<p>However, it also has a problem. The return type is still dependent on <code>Self</code>, so per our <em>existing</em> dyn Rules, that doesn't work. </p>
<p>It should be possible to extend our dyn Rules, though. All that is needed is a bit of &quot;adaptation glue&quot; in the code that is included in the vtable so that it will convert from a <code>Future::PollFn</code> for some fixed <code>T</code> to one that uses a <code>fn</code> pointer. That seems eminently doable, but I'm not sure if it can be expressed in the language today. </p>
<p>Pursuing this road might lead to a fundamental extension in dyn safety, which would be nice!</p>
<h3 id="what-state-is-added-precisely-to-the-struct"><a class="header" href="#what-state-is-added-precisely-to-the-struct">What state is added precisely to the struct?</a></h3>
<ul>
<li>An integer recording the await point where the future is blocked</li>
<li>Fields for any data that outlives the await</li>
</ul>
<h3 id="what-if-i-dont-want-lots-of-state-added-to-my-struct"><a class="header" href="#what-if-i-dont-want-lots-of-state-added-to-my-struct">What if I don't want lots of state added to my struct?</a></h3>
<p>We could limit the use of variables live across an await.</p>
<h3 id="could-we-extend-this-to-other-traits"><a class="header" href="#could-we-extend-this-to-other-traits">Could we extend this to other traits?</a></h3>
<p>e.g., simulacrum mentioned <code>-&gt; impl Iterator</code> in a (dyn-safe) trait. Seems plausible.</p>
<h3 id="why-do-you-only-permit-mut-self-methods"><a class="header" href="#why-do-you-only-permit-mut-self-methods">Why do you only permit <code>&amp;mut self</code> methods?</a></h3>
<p>Since the state for the future is stored inline in the struct, we can only have one active future at a time. Using <code>&amp;mut self</code> ensures that the poll function is only in use by one future at a time, since that future would be holding an <code>&amp;mut</code> reference to the receiver.</p>
<h3 id="we-would-like-to-implement-asyncread-for-all-mut-impl-asyncread-how-can-we-enable-that"><a class="header" href="#we-would-like-to-implement-asyncread-for-all-mut-impl-asyncread-how-can-we-enable-that">We would like to implement <code>AsyncRead</code> for all <code>&amp;mut impl AsyncRead</code>, how can we enable that?</a></h3>
<p>I think this <em>should</em> be possible. The trick is that the poll function would just dispatch to another poll function. We might be able to support it by detecting the pattern of the <code>async fn</code> directly awaiting something reachable from self and supporting that for arbitrary types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: AsyncRead&gt; AsyncRead for &amp;mut T {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt; {
        T::read(self, buf).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically this compiles to a <code>poll_read</code> that just tweaks dispatches to another <code>poll_read</code> with some derefs.</p>
<h3 id="can-you-implement-both-asyncread-and-asyncwrite-for-the-same-type-with-this-technique"><a class="header" href="#can-you-implement-both-asyncread-and-asyncwrite-for-the-same-type-with-this-technique">Can you implement both AsyncRead and AsyncWrite for the same type with this technique?</a></h3>
<p>You can, but you can't simultaneously read and write from the same value. You would need a split-like API. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-dyn-impls"><a class="header" href="#custom-dyn-impls">Custom dyn impls</a></h1>
<p>As described in <a href="evaluation/design/../challenges/dyn_traits.html">dyn traits</a>, <code>dyn Trait</code> types cannot include the types of each future without defeating their purpose; but outside of a <code>dyn</code> context, we <em>want</em> those associated types to have unique values for each impl. Threading this needle requires extending Rust so that the value of an associated type can be different for a <code>dyn Trait</code> and for the underlying impl.</p>
<h2 id="how-it-works-today"><a class="header" href="#how-it-works-today">How it works today</a></h2>
<p>Conceptually, today, there is a kind of &quot;generated impl&quot; for each trait. This impl implements each method by indirecting through the vtable, and it takes the value of associated types from the dyn type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;

    fn method(&amp;self);
}

impl&lt;B&gt; Foo for dyn Foo&lt;Bar = B&gt; {
    type Bar = B;

    fn method(&amp;self) {
        let f: fn(&amp;Self) = get_method_from_vtable(self)
        f(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Meanwhile, at the point where a type (say <code>u32</code>) is coerced to a <code>dyn Foo</code>, we generate a vtable based on the impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Given
impl Foo for u32 {
    fn method(self: &amp;u32) { XXX }
}

// we could a compile for `method`:
// fn `&lt;u32 as Foo&gt;::method`(self: &amp;u32) { XXX }

fn eg() {
    let x: u32 = 22;
    &amp;x as &amp;dyn Foo // &lt;-- this case
}

// generates a vtable with a pointer to that method:
//
// Vtable_Foo = [ ..., `&lt;u32 as Foo&gt;::method` ]
<span class="boring">}
</span></code></pre></pre>
<p>Note that there are some known problems here, such as <a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-01-13-dyn-trait-and-coherence.md">soundness holes in the coherence check</a>.</p>
<h2 id="rough-proposal"><a class="header" href="#rough-proposal">Rough proposal</a></h2>
<p>What we would like is the ability for this &quot;dyn&quot; impl to diverge more from the underlying impl. For example, given a trait <code>Foo</code> with an <code>async</code> fn method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    async fn method(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler might generate an impl like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B&gt; Foo for dyn Foo {
    //          ^^^^^^^ note that this type doesn't include Bar = ...

    type Bar = Box&lt;dyn Future&lt;Output = ()&gt;&gt;;
    //         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ because the result is hardcoded

    fn method(&amp;self) -&gt; Box&lt;dyn Future&lt;Output = ()&gt;&gt; {
        let f: fn(&amp;Self) = get_method_from_vtable(self)
        f(self) 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The vtable, meanwhile, resembles what we had before, except that it doesn't point directly to <code>&lt;u32 as Foo&gt;::method</code>, but rather to a wrapper function (let's call it <code>methodX</code>) that has the job of coercing from the concrete type into a <code>Box&lt;dyn Future&gt;</code>:</p>
<pre><code>// Vtable_Foo = [ ..., `&lt;u32 as Foo&gt;::methodX`]
// fn `&lt;u32 as Foo&gt;::method`(self: &amp;u32) { XXX  }
// fn `&lt;u32 as Foo&gt;::methodX`(self: &amp;u32) -&gt; Box&lt;dyn&gt; { Box::new(TheFuture)  }
</code></pre>
<h2 id="auto-traits"><a class="header" href="#auto-traits">Auto traits</a></h2>
<p>To handle &quot;auto traits&quot;, we need multiple impls. For example, assuming we adopted <a href="evaluation/design/./trait_multiplication.html">trait multiplication</a>, we would have multiple impls, one for <code>dyn Foo</code> and one for <code>dyn Foo * Send</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    async fn method(&amp;self);
}

impl&lt;B&gt; Foo for dyn Foo {
    type Bar = Box&lt;dyn Future&lt;Output = ()&gt;&gt;;

    fn method(&amp;self) -&gt; Box&lt;dyn Future&lt;Output = ()&gt;&gt; {
            
    }
}

impl&lt;B&gt; Foo for dyn Foo * Send {
    //          ^^^^^^^^^^^^^^

    type Bar = Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;;
    //         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    fn method(&amp;self) -&gt; Box&lt;dyn Future&lt;Output = ()&gt;&gt; {
            ....
    }
}

// compiles to:
//
// Vtable_Foo = [ ..., `&lt;u32 as Foo&gt;::methodX`]
// fn `&lt;u32 as Foo&gt;::method`(self: &amp;u32) { XXX  }
// fn `&lt;u32 as Foo&gt;::methodX`(self: &amp;u32) -&gt; Box&lt;dyn&gt; { Box::new(TheFuture)  }
<span class="boring">}
</span></code></pre></pre>
<h3 id="hard-coding-box"><a class="header" href="#hard-coding-box">Hard-coding box</a></h3>
<p>One challenge is that we are hard-coding <code>Box</code> in the above impls. We could control this in a number of ways:</p>
<ul>
<li>Annotate the trait with an alternate wrapper type</li>
<li>Extend <code>dyn</code> types with some kind of indicator of the wrapper (<code>dyn(Box)</code>) that they use for this case</li>
<li>Generate impls for <code>Box&lt;dyn&gt;</code> -- has several shortcomings</li>
</ul>
<h3 id="applicable"><a class="header" href="#applicable">Applicable</a></h3>
<p>Everything here is applicable more broadly, for example to types that return <code>Iterator</code>.</p>
<p>It'd be nice if we extended this capability of &quot;writing your own dyn impls&quot; to end-users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-traits-consider-async-drop"><a class="header" href="#auto-traits-consider-async-drop">Auto traits consider async drop</a></h1>
<p>One way to solve the <a href="evaluation/design/../challenges/bounding_async_drop.html">bounding async drop</a> challenge is to require that, if a type <code>X</code> implements <code>AsyncDrop</code>, then <code>X: Send</code> only if the type of its async drop future is also <code>Send</code>. The drop trait is already integrated quite deeply into the language, so adding a rule like this would not be particularly challenging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-names"><a class="header" href="#simple-names">Simple names</a></h1>
<p>One simple way to give names to async functions is to just generate a name based on the method. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncIterator {
    type Item;
    async fn next(&amp;mut self) -&gt; Self::Item;
}
<span class="boring">}
</span></code></pre></pre>
<p>could desugar to </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncIterator {
    type Item;
    type Next&lt;'me&gt;: Future&lt;Output = Self::Item&gt; + 'me;
    fn next(&amp;mut self) -&gt; Self::Next&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Users could then name the future with <code>&lt;T as AsyncIterator&gt;::Next&lt;'a&gt;</code>.</p>
<p>This is a simple solution, but not a very general one, and perhaps a bit surprising (for example, there is no explicit declaration of <code>Next</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">📚 Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rfc"><a class="header" href="#-rfc">✨ RFC</a></h1>
<blockquote>
<p>The RFC exists here in draft form. It will be edited and amended over the course of this initiative.
Note that some initiatives produce multiple RFCs.</p>
<p>Until there is an accepted RFC, any feature gates must be labeled as experimental.</p>
<p>When you're ready to start drafting, copy in the <a href="https://raw.githubusercontent.com/rust-lang/rfcs/master/0000-template.md">template text</a> from the <a href="https://github.com/rust-lang/rfcs">rfcs</a> repository.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-discussions"><a class="header" href="#design-discussions">Design discussions</a></h1>
<p>This directory hosts notes on important design discussions along with their resolutions.
In the table of contents, you will find the overall status:</p>
<ul>
<li>✅ -- <strong>Settled!</strong> Input only needed if you have identified a fresh consideration that is not covered by the write-up.</li>
<li>💬 -- <strong>Under active discussion.</strong> Check the write-up, which may contain a list of questions or places where feedback is desired.</li>
<li>💤 -- <strong>Paused.</strong> Not under active discussion, but we may be updating the write-up from time to time with details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-async-fn-in-traits"><a class="header" href="#static-async-fn-in-traits">Static async fn in traits</a></h1>
<h2 id="impact-1"><a class="header" href="#impact-1">Impact</a></h2>
<ul>
<li>Able to write <code>async fn</code> in traits and impls and use them in statically dispatched contexts</li>
<li>Able to easily declare that <code>T: Trait + Send</code> where &quot;every async fn in <code>Trait</code> returns a <code>Send</code> future&quot;</li>
</ul>
<h2 id="design-notes"><a class="header" href="#design-notes">Design notes</a></h2>
<p>Support async fn syntax in traits.</p>
<p>The core idea is that it desugars into <a href="design-discussions/./impl_trait_in_traits.html">impl trait in traits</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait {
    async fn foo(&amp;mut self);
}

// becomes:

trait SomeTrait {
    fn foo&lt;(&amp;mut self) -&gt; impl Future&lt;Output = ()&gt; + '_;
}
<span class="boring">}
</span></code></pre></pre>
<p>Naturally it should also work in an impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SomeTrait for someType {
    async fn foo(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>For async functions in traits to be useful, it is important that traits containing <code>async fn</code> be dyn-safe, which introduces a number of challenges that we have to overcome.</p>
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h2>
<h3 id="can-users-easily-bound-those-gats-with-send-maybe-even-in-the-trait-definition"><a class="header" href="#can-users-easily-bound-those-gats-with-send-maybe-even-in-the-trait-definition">Can users easily bound those GATs with <code>Send</code>, maybe even in the trait definition?</a></h3>
<ul>
<li>People are likely to want to say &quot;I want every future produced by this trait to be Send&quot;, and right now that is quite tedious.</li>
<li>We need a way to do this.</li>
<li>This applies equally to other &quot;<code>-&gt; impl Trait</code> in trait&quot; scenarios.</li>
</ul>
<h3 id="what-about-dyn-traits"><a class="header" href="#what-about-dyn-traits">What about &quot;dyn&quot; traits?</a></h3>
<ul>
<li>See the sections on &quot;inline&quot; and &quot;dyn&quot; async fn in traits below!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-traits"><a class="header" href="#impl-trait-in-traits">impl Trait in traits</a></h1>
<p>This effort is part of the <a href="https://github.com/rust-lang/impl-trait-initiative">impl trait initiative</a>. Some notes are kept here as a summary.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li>Able to write <code>-&gt; impl Trait</code> in traits</li>
<li>Able to write <code>type Foo&lt;..&gt; = impl Trait</code> in impls (<a href="https://github.com/rust-lang/rust/issues/63063">type alias impl trait</a>, <a href="https://github.com/rust-lang/generic-associated-types-initiative">generic associated types</a>))</li>
</ul>
<h2 id="requires"><a class="header" href="#requires">Requires</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/63063">Type alias impl trait</a></li>
<li><a href="https://github.com/rust-lang/generic-associated-types-initiative">Generic associated types</a></li>
</ul>
<h2 id="design-notes-1"><a class="header" href="#design-notes-1">Design notes</a></h2>
<p>Support <code>-&gt; impl Trait</code> (existential impl trait) in traits. Core idea is to desugar such thing into a (possibly generic) associated type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait {
    fn foo&lt;(&amp;mut self) -&gt; impl Future&lt;Output = ()&gt; + '_;
}

// becomes something like:
//
// Editor's note: The name of the associated type is under debate;
// it may or may not be something user can name, though they should
// have *some* syntax for referring to it.

trait SomeTrait {
    type Foo&lt;'me&gt;: Future&lt;Output = ()&gt; + 'me
    where
        Self: 'me;

    async fn foo(&amp;mut self) -&gt; Self::Foo&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>We also need to support <code>-&gt; impl Trait</code> in impls, in which case the body desugars to a &quot;type alias impl trait&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SomeTrait for SomeType {
    fn foo&lt;(&amp;mut self) -&gt; impl Future&lt;Output = ()&gt; + '_ {

    }
}

// becomes something using &quot;type alias impl Trait&quot;, like this:

trait SomeTrait {
    type Foo&lt;'me&gt; = impl Future&lt;Output = ()&gt; + 'me
    where
        Self: 'me;

    fn foo(&amp;mut self) -&gt; Self::Foo&lt;'_&gt; {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="frequently-asked-questions-1"><a class="header" href="#frequently-asked-questions-1">Frequently asked questions</a></h2>
<h3 id="what-is-the-name-of-that-gat-we-introduce"><a class="header" href="#what-is-the-name-of-that-gat-we-introduce">What is the name of that GAT we introduce?</a></h3>
<ul>
<li>I called it <code>Bar</code> here, but that's somewhat arbitrary, perhaps we want to have some generic syntax for naming the method?</li>
<li>Or for getting the type of the method.</li>
<li>This problem applies equally to other &quot;<code>-&gt; impl Trait</code> in trait&quot; scenarios.</li>
<li><a href="https://hackmd.io/IISsYc0fTGSSm2MiMqby4A">Exploration doc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-async-trait"><a class="header" href="#dyn-async-trait">Dyn async trait</a></h1>
<h2 id="impact-2"><a class="header" href="#impact-2">Impact</a></h2>
<ul>
<li>Traits that contain <code>async fn</code> or <a href="design-discussions/./impl_trait_in_traits.html">impl trait in traits</a> can still be dyn safe</li>
<li>Costs like boxing of futures are limited to code that uses <code>dyn Trait</code> and not to all users of the trait</li>
<li>Reasonable defaults around things like <code>Send + Sync</code> and what kind of boxing is used</li>
<li>Ability to customize those defaults for individual traits or on a crate-wide or module-wide basis</li>
</ul>
<h2 id="requires-1"><a class="header" href="#requires-1">Requires</a></h2>
<ul>
<li><a href="design-discussions/./dyn_trait.html">dyn trait</a></li>
</ul>
<h2 id="design-notes-2"><a class="header" href="#design-notes-2">Design notes</a></h2>
<ul>
<li>Permit a trait <code>TheTrait</code> containing  <code>async fn</code> or <a href="design-discussions/./impl_trait_in_traits.html">impl trait in traits</a> to be used with <code>dyn TheTrait</code>, at least if other criteria are met.</li>
<li>Do not require annoying annotations.</li>
<li>Permit the user to select, for <code>TheTrait</code>, how the futures will be boxed or otherwise represented, which would permit us to use <code>Box</code> or potentially other types like <code>SmallBox</code> etc.</li>
<li>User should also be able to control whether the resulting futures are assumed to be send.</li>
</ul>
<h3 id="older-notes"><a class="header" href="#older-notes">Older notes</a></h3>
<p>The most basic desugaring of async fn in traits will make the trait not dyn-safe. &quot;Inline&quot; async fn in traits is one way to circumvent that, but it's not suitable for all traits that must be dyn-safe. There are other efficient options:</p>
<ul>
<li>Return a <code>Box&lt;dyn Async&lt;...&gt;&gt;</code> -- but then we must decide if it will be <code>Send</code>, right? And we'd like to only do that when using the trait as a <code>dyn Trait</code>. Plus it is not compatible with no-std (it is compatible with alloc).
<ul>
<li>This comes down to needing some form of opt-in.</li>
</ul>
</li>
</ul>
<p>This concern applies equally to other &quot;<code>-&gt; impl Trait</code> in trait&quot; scenarios.</p>
<p>We have looked at revising how &quot;dyn traits&quot; are handled more generally in the lang team on a number of occasions, but <a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-01-13-dyn-trait-and-coherence.md">this meeting</a> seems particularly relevant. In that meeting we were discussing some soundness challenges with the existing dyn trait setup and discussing how some of the directions we might go enabled folks to write their <em>own</em> <code>impl Trait for dyn Trait</code> impls, thus defining for themselves how the mapping from Trait to dyn Trait. This seems like a key piece of the solution.</p>
<p>One viable route might be:</p>
<ul>
<li>Traits using <code>async fn</code> are not, by default, dyn safe.</li>
<li>You can declare how you want it to be dyn safe:
<ul>
<li><code>#[repr(inline)]</code></li>
<li>or <code>#[derive(dyn_async_boxed)]</code> or some such
<ul>
<li>to take an <code>#[async_trait]</code>-style approach</li>
</ul>
</li>
<li>It would be nice if users can declare their own styles. For example, Matthias247 pointed out that the <code>Box</code> used to allocate can be reused in between calls for increased efficiency.</li>
</ul>
</li>
<li>It would also be nice if there's an easy, decent default -- maybe you don't even <em>have</em> to opt-in to it if you are not in <code>no_std</code> land.</li>
</ul>
<h2 id="frequently-asked-questions-2"><a class="header" href="#frequently-asked-questions-2">Frequently asked questions</a></h2>
<h3 id="what-are-the-limitations-around-allocation-and-no-std-code"><a class="header" href="#what-are-the-limitations-around-allocation-and-no-std-code">What are the limitations around allocation and no-std code?</a></h3>
<p>&quot;It's complicated&quot;. A lot of no-std code does have an allocator (it depends on alloc), though it may require fallible allocation, or permit allocation of fixed quantities (e.g., only at startup, or so long as it can be known to be O(1)).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait"><a class="header" href="#dyn-trait">Dyn trait</a></h1>
<h2 id="impact-3"><a class="header" href="#impact-3">Impact</a></h2>
<ul>
<li>Soundness holes relating to <code>dyn Trait</code> are closed.</li>
<li>The semver implication of whether a trait is &quot;dyn or not&quot; are clear.</li>
<li>More kinds of traits are dyn-safe.</li>
<li>Easily able to have a &quot;dynamically dispatched core&quot; with helper methods.</li>
<li>Users are able to the &quot;adaptation&quot; from a statically known type (<code>T: Trait</code>) into a <code>dyn Trait</code>.</li>
</ul>
<h2 id="design-notes-3"><a class="header" href="#design-notes-3">Design notes</a></h2>
<h3 id="soundness-holes"><a class="header" href="#soundness-holes">Soundness holes</a></h3>
<p>FIXME-- list various issues here :)</p>
<h3 id="semver-implications"><a class="header" href="#semver-implications">Semver implications</a></h3>
<p>Today, the compiler automatically determines whether a trait is &quot;dyn-safe&quot;. This means that otherwise legal additions to the trait (such as new )</p>
<h3 id="more-kinds-of-traits-are-dyn-safe"><a class="header" href="#more-kinds-of-traits-are-dyn-safe">More kinds of traits are dyn-safe</a></h3>
<p>Currently dyn-safe traits exclude a lot of functionality, such as generic methods. We may be able to lift some of those restrictions.</p>
<h3 id="easily-able-to-have-a-dynamically-dispatched-core-with-helper-methods"><a class="header" href="#easily-able-to-have-a-dynamically-dispatched-core-with-helper-methods">Easily able to have a &quot;dynamically dispatched core&quot; with helper methods</a></h3>
<p>There is a common pattern with e.g. <code>Iterator</code> where there is a dynamically dispatched &quot;core method&quot; (<code>fn next()</code>) and then a variety of combinators and helper methods that use <code>where Self: Sized</code> to side-step dyn-safety checks. These methods often involve generics. We should make this pattern easier and more obvious, and (ideally) make it work better -- e.g., by having those methods <em>also</em> available on <code>dyn Trait</code> receivers (which seems fundamentally possible).</p>
<h3 id="adaptation"><a class="header" href="#adaptation">Adaptation</a></h3>
<p>In the case of async Rust, given a trait <code>Foo</code> that contains <code>async fn</code> methods, we wish to be able to have the user write <code>dyn Foo</code> without having to specify the values of the associated types that contain the future types for those methods. Consider the fully desugard example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Method&lt;..&gt;: Future;
    fn method() -&gt; Self::Method&lt;..&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Roughly speaking we wish to be able to supply an impl like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo for dyn Foo {
    type Method&lt;..&gt; = Box&lt;dyn Future&lt;..&gt;&gt;;
    fn method() -&gt; Self::Method {
        // call, via vtable, a shim that will create the `Box`
        // (or whichever smart pointer is desired)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ideally, this would be a general capability that users can use to control the adaptation of &quot;known types&quot; to <code>dyn</code> types for other traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-drop"><a class="header" href="#async-drop">Async drop</a></h1>
<h2 id="impact-4"><a class="header" href="#impact-4">Impact</a></h2>
<ul>
<li>Able to create types (database connections etc) that perform async operations on cleanup</li>
<li>Able to detect when such types are dropped synchronously</li>
<li>Able to identify the await points that result from async cleanup if needed</li>
</ul>
<h2 id="design-notes-4"><a class="header" href="#design-notes-4">Design notes</a></h2>
<p>We can create a <code>AsyncDrop</code> variant that contains an <code>async fn</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsyncDrop for MyType {
    async fn drop(&amp;mut self) {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Like <code>Drop</code>, the <code>AsyncDrop</code> trait must be implemented for all values of its self-type.</p>
<h3 id="async-drop-glue"><a class="header" href="#async-drop-glue">Async drop glue</a></h3>
<p>Within async functions, when we drop a value, we will invoke &quot;async drop glue&quot; instead of &quot;drop glue&quot;. &quot;Async drop glue&quot; works in the same basic way as &quot;drop glue&quot;, except that it invokes <code>AsyncDrop</code> where appropriate (and may suspend):</p>
<ul>
<li>The async drop glue for a type T first executes the <code>AsyncDrop</code> method
<ul>
<li>If <code>T</code> has no <code>AsyncDrop</code> impl, then the glue executes the synchronous <code>Drop</code> impl
<ul>
<li>If <code>T</code> has no <code>Drop</code> impl, then this is a no-op</li>
</ul>
</li>
</ul>
</li>
<li>The async drop glue then recursively &quot;async drops&quot; all fields of T</li>
</ul>
<h3 id="auto-traits-1"><a class="header" href="#auto-traits-1">Auto traits</a></h3>
<p>Rust presently assumes <em>all</em> types are droppable. Consider a function <code>foo</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo&lt;T&gt;(x: T) {}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we will drop <code>x</code> when <code>foo</code> returns, but we do not know whether <code>T</code> implements <code>AsyncDrop</code> or not, and we won't know until monomorphization. However, to know whether the resulting future for <code>foo(x)</code> is <code>Send</code>, we have to know whether the code that drops <code>x</code> will be send. So we must come up with a way to know that <code>T: Send</code> implies that the async drop future for <code>T</code> is <code>Send</code>.</p>
<h3 id="explicit-async-drop"><a class="header" href="#explicit-async-drop">Explicit async drop</a></h3>
<p>We should have a <code>std::mem::async_drop</code> analogous to <code>std::mem::drop</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn async_drop&lt;T&gt;(x: T) { }
<span class="boring">}
</span></code></pre></pre>
<h3 id="implicit-await-points"><a class="header" href="#implicit-await-points">Implicit await points</a></h3>
<p>When you run async drop glue, there is an implicit await point. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(dbc: DatabaseConnection) -&gt; io::Result&lt;()&gt; {
    let data = socket().read().await?;
    dbc.write(data).await?;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, presuming that <code>DatabaseConnection</code> implements <code>AsyncDrop</code>, there are actually a number of async drops occurring:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(dbc: DatabaseConnection) -&gt; io::Result&lt;()&gt; {
    let data = match socket().read().await {
        Ok(v) =&gt; v,
        Err(e) =&gt; {
            std::mem::async_drop(dbc).await;
            return e;
        }
    };
    let () = match dbc.write(data).await? {
        Ok(()) =&gt; (),
        Err(e) =&gt; {
            std::mem::async_drop(dbc).await;
            return e;
        }
    };
    std::mem::async_drop(dbc).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>As this example shows, there are important ergonomic benefits here to implicit async drop, and it also ensures that async and sync code work in analogous ways. However, implicit await points can be a hazard for some applications, where it is important to identify all await points explicitly (for example, authors of embedded applications use await points to reason about what values will be stored in the resulting future vs the stack of the poll function). To further complicate things, async-drop doesn't only execute at the end of a block or an &quot;abrupt&quot; expression like <code>?</code>: async-drop can also execute at the end of every statement, given temporary values.</p>
<p>The best solution here is unclear. We could have an &quot;allow-by-default&quot; lint encouraging explicit use of <code>async_drop</code>, but as the code above shows, the result may be highly unergonomic (also, imagine how it looks as the number of variables requiring async-drop grows).</p>
<p>Another option is to target the problem from another angle, for example by adding lints to identify when large values are stored in a future or on the stack, or to allow developers to tag local variables that they expect to be stored on the stack, and have the compiler warn them if this turns out to not be true. Users could then choose how to resolve the problem (for example, by shortening the lifetime of the value so that it is not live across an await).</p>
<h4 id="running-destructors-concurrently"><a class="header" href="#running-destructors-concurrently">Running destructors concurrently</a></h4>
<p>It's often the case that at the end of a function or scope, multiple destructors are run. In general the order (which is the reverse order of initialization) matters, since one local could borrow from another, or there is some other logical dependency between them.</p>
<p>However, in some cases the order might not matter at all. In async, it would be possible to run destructors for multiple locals concurrently. As an example, we could mark the destructors like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[concurrent]
impl AsyncDrop for Foo {
    async fn drop(&amp;mut self) { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>#[concurrent]</code> means that <code>Foo</code> does not take <em>logical</em> dependencies or dependents with other values, and it is safe to drop concurrently. (The compiler would still enforce memory safety, of course.)</p>
<p>In these cases, however, it's usually enough to impl <em>synchronous</em> Drop and spawn a task for the &quot;real&quot; destructor. That keeps the language simple, though it's less convenient to write.</p>
<h3 id="preventing-sync-drop"><a class="header" href="#preventing-sync-drop">Preventing sync drop</a></h3>
<p>It is easy enough to make async-drop be used, but it is currently not possible to prevent sync drop, even from within an async setting. Consider an example such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(dbc: DatabaseConnection) -&gt; io::Result&lt;()&gt; {
    drop(dbc);
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler could however lint against invoking (or defining!) synchronous functions that take ownership of values whose types implement <code>AsyncDrop</code>. This would catch code like the case above. We may have to tune the lint to avoid false warnings. Note that it is important to lint <em>both</em> invocation <em>and</em> definition sites because the synchronous function may be generic (like <code>drop</code>, in fact).</p>
<p>The question remains: what should code that implements <code>AsyncDrop</code> <em>do</em> if synchronous <code>Drop</code> is invoked? One option is panic, but that is suboptimal, as panic from within a destructor is considered bad practice. Another option is to simply abort. A final option is to have some form of portable &quot;block-on&quot; that would work, but this is effectively the (as yet unsolved) <a href="https://rust-lang.github.io/wg-async-foundations/vision/shiny_future/users_manual.html#bridging-the-sync-and-async-worlds">async-sync-async sandwich problem</a>.</p>
<p>Preventing this 'properly' would require changing fundamental Rust assumptions (e.g., by introducing the <code>?Drop</code> trait). While such a change would make Rust more expressive, it also carries complexity and composition hazards, and would require thorough exploration. It is also a step that could be taken later (although it would require some form of explicit <code>impl !Drop</code> opt-in by types to avoid semver breakage).</p>
<h3 id="supporting-both-sync-and-async-drop"><a class="header" href="#supporting-both-sync-and-async-drop">Supporting both sync and async drop</a></h3>
<p>It should perhaps be possible to support <em>both</em> sync and async drop. It is not clear though if there are any real use cases for this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-closures"><a class="header" href="#async-closures">Async closures</a></h1>
<h2 id="impact-5"><a class="header" href="#impact-5">Impact</a></h2>
<ul>
<li>Able to create async closures that work like ordinary closures but which can await values.</li>
<li>Analogous traits to <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>, etc</li>
<li>Reconcile async blocks and async closures</li>
</ul>
<h2 id="design-notes-5"><a class="header" href="#design-notes-5">Design notes</a></h2>
<p>Async functions need their own traits, analogous to <code>Fn</code> and friends:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(async_inline)]
trait AsyncFnOnce&lt;A&gt; {
    type Output;

    // Uh-oh! You can't encode these as `async fn` using inline async functions!
    async fn call(mut self, args: A) -&gt; Self::Output;
}

#[repr(async_inline)]
trait AsyncFnMut: AsyncFnOnce {
    type Output;

    async fn call_mut(&amp;mut self, args: A) -&gt; Self::Output;
}

#[repr(async_inline)]
trait AsyncFn: AsyncFnMut {
    // Uh-oh! You can't encode these as `async fn` using inline async functions!
    async fn call(&amp;self, args: A) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>Some notes:</p>
<p><code>AsyncFnOnce</code> is almost the same as <code>Future</code>/<code>Async</code> -- both represent, effectively, a future that can be driven exactly once. The difference is that your type can distinguish statically between the uncalled state and the persistent state after being called, if you wish, by using separate types for each. This can be useful for situations where an <code>async fn</code> is <code>Send</code> up until the point it is called, at which point it creates inner state that is not <code>Send</code>.</p>
<p>The concept of <code>AsyncFn</code> is more clear, but it requires storing the state externally to make sense: how else can there be multiple parallel executions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-frequently-asked-questions"><a class="header" href="#-frequently-asked-questions">😕 Frequently asked questions</a></h1>
<blockquote>
<p>This page lists frequently asked questions about the design. It often redirects to the other pages on the site.</p>
</blockquote>
<h2 id="what-is-the-goal-of-this-initiative"><a class="header" href="#what-is-the-goal-of-this-initiative">What is the goal of this initiative?</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>
<h2 id="who-is-working-on-it"><a class="header" href="#who-is-working-on-it">Who is working on it!</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
